import{_ as e,e as a,q as s,D as l,x as n,Z as p,o as t}from"./chunks/framework.tCCUWFfl.js";const b=JSON.parse('{"title":"Promise","description":"详细介绍promise","frontmatter":{"title":"Promise","description":"详细介绍promise","category":"javascript","tags":["javascript","promise"]},"headers":[],"relativePath":"frontend/javascript/promise.md","filePath":"frontend/javascript/promise.md","lastUpdated":1686488104000}'),o={name:"frontend/javascript/promise.md"},r={id:"frontmatter-title",tabindex:"-1"},h=s("a",{class:"header-anchor",href:"#frontmatter-title","aria-label":'Permalink to "{{ $frontmatter.title }}"'},"​",-1),d=p(`<p><code>Promise</code> 是一个对象，它代表了一个异步操作的最终完成或者失败。<code>Promise</code> 是异步编程的一种解决方案，是一个构造函数</p><h2 id="使用" tabindex="-1">使用 <a class="header-anchor" href="#使用" aria-label="Permalink to &quot;使用&quot;">​</a></h2><p><code>Promise</code> 实例化的时候传入的是一个函数，函数中接收两个函数参数：<code>resolve</code> 和 <code>reject</code>：</p><ul><li><p><code>resolve</code>：把 <code>Promise</code> 的状态由进行中变为成功状态；</p></li><li><p><code>reject</code>：把 <code>Promise</code> 的状态由进行中变为失败状态。</p></li></ul><div class="language-ts vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> promise</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Promise</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">resolve</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">reject</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  resolve</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">promise.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">then</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">res</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(res) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// trre</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><h2 id="状态" tabindex="-1">状态 <a class="header-anchor" href="#状态" aria-label="Permalink to &quot;状态&quot;">​</a></h2><ul><li><p><code>pending</code>：进行中，表示 <code>Promise</code> 还在执行阶段，没有执行完成。</p></li><li><p><code>fulfilled</code>：成功状态，表示 <code>Promise</code> 成功执行<strong>完成</strong>。</p></li><li><p><code>rejected</code>：拒绝状态，表示 <code>Promise</code> 执行被拒绝，也就是<strong>失败</strong>。</p></li></ul><p><code>Promise</code> 的状态，只可能是其中一种状态，从进行中变为成功或失败状态之后，状态就固定了，不会再发生改变。</p><h2 id="实例方法" tabindex="-1">实例方法 <a class="header-anchor" href="#实例方法" aria-label="Permalink to &quot;实例方法&quot;">​</a></h2><ul><li><strong><code>then</code></strong></li></ul><p>执行 <code>resolve</code> 时，<code>Promise</code> 状态从 <code>pending</code> 变为 <code>fulfilled</code> ，会执行 <code>.then </code>方法。<code>then</code> 方法接收的参数也是一个函数，函数中携带一个参数，该参数是 <code>resolve(res)</code> 返回的数据。</p><ul><li><strong><code>catch</code></strong></li></ul><p>执行 <code>reject</code> 时，<code>Promise</code> 状态从 <code>pending</code> 变为 <code>rejected</code>，会执行 <code>.catch</code> 方法。<code>catch</code> 方法接收的也是一个函数，函数中携带一个参数，该参数为 <code>reject(err)</code> 返回的数据。</p><ul><li><strong><code>finally</code></strong></li></ul><p>无论执行的结果是成功还是失败，最终都会执行 <code>.finally</code> 方法。<code>finally</code> 方法接收的也是一个函数。</p><p><code>then</code> 和 <code>catch</code> 支持链式操作</p><h2 id="静态方法" tabindex="-1">静态方法 <a class="header-anchor" href="#静态方法" aria-label="Permalink to &quot;静态方法&quot;">​</a></h2><h3 id="promise-all" tabindex="-1">Promise.all <a class="header-anchor" href="#promise-all" aria-label="Permalink to &quot;Promise.all&quot;">​</a></h3><blockquote><p><code>Promise.all</code> 等待<strong>所有都完成</strong>或<strong>第一个失败</strong>。</p><blockquote><p><code>Promise.all</code> <strong>当且仅当</strong>传入的可迭代对象<strong>为空</strong>时为<strong>同步</strong></p></blockquote></blockquote><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/all" target="_blank" rel="noreferrer">Promise.all()</a> 方法接收 <code>iterable</code> 类型数据并且返回一个 <code>Promise</code> 实例，返回值将会按照传入的顺序返回。</p><blockquote><p>注：Array，String，Map，Set 都属于 ES6 的 iterable 类型。</p></blockquote><ul><li>同步返回：返回一个完成的 <code>Promise</code>。</li></ul><p>当且仅当传入的参数是一个空的可迭代对象，返回一个已完成（<code>already resolved</code>）状态的 <code>Promise</code>。</p><div class="language-ts vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Promise</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">all</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">([])) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// will be immediately resolved: Promise { &lt;state&gt;: &quot;fulfilled&quot;, &lt;value&gt;: Array[0] }</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><ul><li><p>异步返回：返回一个处理中（<code>pending</code>）的 <code>Promise</code>。</p><ul><li><p>如果传入的参数不包含任何 <code>promise</code>，则返回一个异步完成（<code>asynchronously resolved</code>）<code>Promise</code>。</p><div class="warning custom-block"><p class="custom-block-title">WARNING</p><p><code>Google Chrome 58</code> 在这种情况下返回一个已完成（<code>already resolved</code>）状态的 <code>Promise</code>。</p></div></li><li><p>其他情况下这个返回的 <code>promise</code> 之后会在所有的 <code>promise</code> 都完成或有一个 <code>promise</code> 失败时异步地变为完成或失败。</p></li></ul></li></ul><div class="language-ts vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> p1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Promise</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">all</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">([ </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1337</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;hi&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ])</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> p2</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Promise</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">all</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">([ </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Promise</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">resolve</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1337</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">), </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;hi&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ])</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(p1) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// asynchronously: Promise { &lt;state&gt;: &quot;pending&quot; }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(p2) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Promise { &lt;state&gt;: &quot;pending&quot; }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">setTimeout</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> () {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;the stack is now empty&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(p1); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Promise { &lt;state&gt;: &quot;fulfilled&quot;, &lt;value&gt;: Array[2] }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(p2); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Promise { &lt;state&gt;: &quot;fulfilled&quot;, &lt;value&gt;: Array[2] }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><h3 id="promise-allsettled" tabindex="-1">Promise.allSettled <a class="header-anchor" href="#promise-allsettled" aria-label="Permalink to &quot;Promise.allSettled&quot;">​</a></h3><blockquote><p><code>Promise.allSettled</code> 等待所有结果已敲定（成功或者失败）</p></blockquote><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/allSettled" target="_blank" rel="noreferrer">Promise.allSettled()</a> 方法接收 <code>iterable</code> 类型数据并且返回一个 <code>Promise</code> 实例，返回值是带有带有描述每个 <code>promsie</code> 结果的对象数组</p><ul><li>同步返回：返回一个完成的 <code>Promise</code>。</li></ul><p>当且仅当传入的参数是一个空的可迭代对象，返回一个已完成（<code>already resolved</code>）状态的 <code>Promise</code>。</p><div class="language-ts vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Promise</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">allSettled</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">([])) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// will be immediately resolved: Promise { &lt;state&gt;: &quot;fulfilled&quot;, &lt;value&gt;: Array[0] }</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><ul><li>异步返回：返回一个处理中（<code>pending</code>）的 <code>Promise</code>。</li></ul><p>返回的 <code>promise</code> 在给定的 <code>iterable</code> 中所有 <code>promise</code> 已经敲定时（要么已兑现，要么已拒绝）变为成功。</p><p><strong>每个结果对象都有以下的属性：</strong></p><ul><li><p><code>status</code>：一个字符串，要么是 <code>fulfilled</code>，要么是 <code>rejected</code>，表示 <code>promise</code> 的最终状态。</p></li><li><p><code>value</code>：仅当 <code>status</code> 为 <code>fulfilled</code>，才存在。在 <code>promise</code> 兑现时才有 <code>value</code>。</p></li><li><p><code>reason</code>：仅当 <code>status</code> 为 <code>rejected</code>，才存在，在 <code>promise</code> 拒绝时才有 <code>reason</code>。</p></li></ul><div class="tip custom-block"><p class="custom-block-title">TIP</p><ul><li><p><code>Promise.allSettled()</code> 方法是 <code>promise</code> 并发性方法的其中之一。在你有多个不依赖于彼此成功完成的异步任务时，或者你总是想知道每个 <code>promise</code> 的结果时，使用 <code>Promise.allSettled()</code>。</p></li><li><p>相比之下，如果任务相互依赖，或者如果你想立即拒绝其中任何任务，<code>Promise.all()</code> 返回的 <code>Promise</code> 可能更合适。</p></li></ul></div><h3 id="promise-race" tabindex="-1">Promise.race <a class="header-anchor" href="#promise-race" aria-label="Permalink to &quot;Promise.race&quot;">​</a></h3><blockquote><p><code>Promise.race</code> 等待任意一个兑现或拒绝</p></blockquote><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/race" target="_blank" rel="noreferrer">Promise.race()</a> 方法接收 <code>iterable</code> 类型数据并且返回一个 <code>Promise</code> 实例。</p><p>返回一个处理中（<code>pending</code>）的 <code>Promise</code>。迭代器中的任意一个 <code>promise</code> 解决或拒绝，返回的 <code>promise</code> 就会异步地解析或拒绝（一旦堆栈为空）。</p><ul><li><p>如果传的迭代是空的，则返回的 <code>promise</code> 将永远等待。</p></li><li><p>传入的参数不包含任何 <code>promise</code> 或者是已解决/拒绝的 <code>promise</code>，则 <code>Promise.race</code> 将解析为迭代中找到的第一个值。</p></li></ul><h3 id="promise-any" tabindex="-1">Promise.any <a class="header-anchor" href="#promise-any" aria-label="Permalink to &quot;Promise.any&quot;">​</a></h3><blockquote><p><code>Promise.any</code> 等待任意一个已兑现或全部拒绝</p></blockquote><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/any" target="_blank" rel="noreferrer">Promise.any()</a> 方法接收 <code>iterable</code> 类型数据并且返回一个 <code>Promise</code> 实例。</p><ul><li><p>如果传入的可迭代对象是非空的，那么当可迭代对象内的任意一个 <code>promise</code> 兑现后，或者当可迭代对象内存在非 <code>promise</code> 值时，该方法所返回的 <code>promise</code> 都会异步的变成兑现状态。</p></li><li><p>如果传入了一个空的可迭代数组，那么该方法就会同步返回一个已经被拒 <code>promise</code>，其拒因是一个 <code>AggregateError</code> 实例，该实例的 <code>errors</code> 属性会是一个空数组。</p></li></ul><h3 id="promise-reject" tabindex="-1">Promise.reject <a class="header-anchor" href="#promise-reject" aria-label="Permalink to &quot;Promise.reject&quot;">​</a></h3><p><code>Promise.reject()</code> 方法返回一个带有拒绝原因的 <code>Promise</code> 对象</p><div class="language-ts vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Promise</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">reject</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 等同于</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">new</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Promise</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">resolve</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">reject</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  reject</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h3 id="promise-resolve" tabindex="-1">Promise.resolve <a class="header-anchor" href="#promise-resolve" aria-label="Permalink to &quot;Promise.resolve&quot;">​</a></h3><p><code>Promise.resolve()</code> 方法将给定的值 <code>resolves</code> 为 <code>Promise</code>。 如果值是一个 <code>thenable</code>，<code>Promise.resolve</code> 将调用 <code>then</code> 方法，并准备两个回调；否则，返回的 <code>Promise</code> 将以该值实现。</p><ol><li><p>如果参数本身就是一个 <code>Promise</code> 对象，则直接返回这个 <code>Promise</code> 对象。</p></li><li><p>如果参数是一个 <code>thenable</code> 对象</p></li></ol><p><code>thenable</code> 对象指的是具有 <code>then</code> 方法的对象：</p><div class="language-ts vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> thenable </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  then</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">resolve</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">reject</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    resolve</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(thenable)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p><code>Promise.resolve</code> 方法会将这个对象转为 <code>Promise</code> 对象，然后就立即执行 <code>thenable</code> 对象的 <code>then</code> 方法。</p><div class="language-ts vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> thenable </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  then</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">resolve</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">reject</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    resolve</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">42</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> p1 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Promise</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">resolve</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(thenable);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">p1.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">then</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">value</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(value);  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 42</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p><code>thenable</code> 对象的 <code>then</code> 方法执行后，对象 <code>p1</code> 的状态就变为 <code>resolved</code>，从而立即执行最后那个 <code>then</code> 方法指定的回调函数，输出 <code>42</code></p><div class="warning custom-block"><p class="custom-block-title">WARNING</p><ul><li>不要在解析为自身的 <code>thenable</code> 上调用 <code>Promise.resolve</code>。这将导致无限递归，因为它试图展平无限嵌套的 <code>promise</code></li></ul><div class="language-ts vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> thenable </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  then</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">resolve</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">reject</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    resolve</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(thenable)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Promise</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">resolve</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(thenable) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//这会造成一个死循环</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div></div><ol start="3"><li>如果参数不是具有then方法的对象或者是一个原始值</li></ol><p><code>Promise.resolve</code> 方法返回一个新的 <code>Promise</code> 对象，状态为 <code>resolved</code>。</p><ol start="4"><li>不带有任何参数</li></ol><p><code>Promise.resolve</code> 方法允许调用时不带参数，直接返回一个 <code>resolved</code> 状态的 <code>Promise</code> 对象。</p><div class="warning custom-block"><p class="custom-block-title">WARNING</p><ul><li><p>立即 <code>resolve</code> 的 <code>Promise</code> 对象，是在本轮 <strong>事件循环</strong> （event loop）的结束时执行执行，不是马上执行，也不是在下一轮 <strong>事件循环</strong> 的开始时执行</p></li><li><p>原因：传递到 <code>then()</code> 中的函数被置入了一个微任务队列，而不是立即执行，这意味着它是在 <code>JavaScript</code> 事件队列的所有运行时结束了，事件队列被清空之后，才开始执行</p></li></ul></div><hr><p><strong>resolve()本质作用</strong></p><ul><li><p><code>resolve()</code> 是用来表示 <code>promise</code> 的状态为 <code>fulfilled</code>，相当于只是定义了一个有状态的 Promise，但是并没有调用它；</p></li><li><p><code>promise</code> 调用 <code>then</code> 的前提是 <code>promise</code> 的状态为 <code>fulfilled</code>；</p></li><li><p>只有 <code>promise</code> 调用 <code>then</code> 的时候，<code>then</code> 里面的函数才会被推入微任务中；</p></li></ul>`,66);function k(i,c,E,g,m,u){return t(),a("div",null,[s("h1",r,[l(n(i.$frontmatter.title)+" ",1),h]),d])}const F=e(o,[["render",k]]);export{b as __pageData,F as default};
