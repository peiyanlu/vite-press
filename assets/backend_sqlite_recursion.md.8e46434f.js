import{_ as e,o as a,c as n,k as t,a as l,t as d,U as r}from"./chunks/framework.c0c21d38.js";const f=JSON.parse('{"title":"SQLite 递归查询","description":"递归查询","frontmatter":{"title":"SQLite 递归查询","description":"递归查询","category":"sqlite","tags":["sqlite"]},"headers":[],"relativePath":"backend/sqlite/recursion.md","filePath":"backend/sqlite/recursion.md","lastUpdated":1705048859000}'),o={name:"backend/sqlite/recursion.md"},p={id:"frontmatter-title",tabindex:"-1"},i=t("a",{class:"header-anchor",href:"#frontmatter-title","aria-label":'Permalink to "{{ $frontmatter.title }}"'},"​",-1),c=r(`<p><code>SQLite</code> 的 <code>with</code> 从句提供了一种递归语法，可以有效地对树和图等结构进行查询</p><table><thead><tr><th>id</th><th>name</th><th>father</th><th>emperor_no</th></tr></thead><tbody><tr><td>1</td><td>曹操</td><td></td><td></td></tr><tr><td>2</td><td>曹植</td><td>1</td><td></td></tr><tr><td>3</td><td>曹丕</td><td>1</td><td>1</td></tr><tr><td>4</td><td>曹彰</td><td>1</td><td></td></tr><tr><td>5</td><td>曹冲</td><td>1</td><td></td></tr><tr><td>6</td><td>曹宇</td><td>1</td><td></td></tr><tr><td>7</td><td>曹楷</td><td>4</td><td></td></tr><tr><td>8</td><td>曹芳</td><td>7</td><td>3</td></tr><tr><td>9</td><td>曹睿</td><td>3</td><td>2</td></tr><tr><td>10</td><td>曹霖</td><td>3</td><td></td></tr><tr><td>11</td><td>曹髦</td><td>10</td><td>4</td></tr><tr><td>12</td><td>曹奂</td><td>6</td><td>5</td></tr></tbody></table><p>如果我们要求获取曹操所有的后代里，当过皇帝的人，并且按照代际顺序输出（子代-&gt;孙代-&gt;曾孙代）。这便是一个典型的广度优先搜索（Breadth First Search），该功能可用以下 <code>SQL</code> 语句进行查询：</p><div class="language-shell line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#FFCB6B;">with</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">recursive</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#FFCB6B;">cao</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">as</span><span style="color:#A6ACCD;"> (</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#89DDFF;font-style:italic;">select</span><span style="color:#A6ACCD;"> * from family where name = </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">曹操</span><span style="color:#89DDFF;">&#39;</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#FFCB6B;">union</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">all</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#89DDFF;font-style:italic;">select</span><span style="color:#A6ACCD;"> family.* from cao join family on cao.id = family.father</span></span>
<span class="line"><span style="color:#A6ACCD;">    )</span></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">select</span><span style="color:#A6ACCD;"> * from cao where emperor_no is not null</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p><code>SQLite</code> 递归建表的核心是一条以 <code>union(all)</code> 连接的复合查询语句，其中 <code>union</code> 前面的语句构成递归搜索的起始数据，<code>union</code> 后的语句构成递归查询的生成语句（取出当前节点的所有子节点）。</p><p>如果写过基于队列来对树形结构进行广度优先搜索，那么会对 SQLite 这一语法很容易理解：</p><ol><li>在队列里产生初始数据</li><li>取出队列中的元素，输出该元素</li><li>将2步取出的元素，获取它的所有子节点，放入队列</li><li>继续进行第2步，直到队列为空</li></ol><hr><div class="language-shell line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;font-style:italic;">select</span><span style="color:#A6ACCD;"> * from family where name = </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">曹操</span><span style="color:#89DDFF;">&#39;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>取出根节点，也就是曹操</p><div class="language-shell line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;font-style:italic;">select</span><span style="color:#A6ACCD;"> family.* from cao join family on cao.id = family.father</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>取出当前遍历节点的所有子节点</p><div class="warning custom-block"><p class="custom-block-title">WARNING</p><p>虽然最终所有的输出结果都会到表cao里，但在生成语句里，cao指代的只是当前的遍历节点，它在生成语句里，只有一行数据</p></div><div class="language-shell line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;font-style:italic;">select</span><span style="color:#A6ACCD;"> * from cao where emperor_no is not null</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>结果如下：</p><table><thead><tr><th>id</th><th>name</th><th>father</th><th>emperor_no</th></tr></thead><tbody><tr><td>3</td><td>曹丕</td><td>1</td><td>1</td></tr><tr><td>9</td><td>曹睿</td><td>3</td><td>2</td></tr><tr><td>12</td><td>曹奂</td><td>6</td><td>5</td></tr><tr><td>11</td><td>曹髦</td><td>10</td><td>4</td></tr><tr><td>8</td><td>曹芳</td><td>7</td><td>3</td></tr></tbody></table>`,16);function h(s,m,y,u,b,C){return a(),n("div",null,[t("h1",p,[l(d(s.$frontmatter.title)+" ",1),i]),c])}const A=e(o,[["render",h]]);export{f as __pageData,A as default};
