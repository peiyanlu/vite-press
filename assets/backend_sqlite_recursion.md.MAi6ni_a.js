import{_ as e,e as a,q as t,D as i,x as d,Z as n,o as l}from"./chunks/framework.tCCUWFfl.js";const E=JSON.parse('{"title":"SQLite 递归查询","description":"递归查询","frontmatter":{"title":"SQLite 递归查询","description":"递归查询","category":"sqlite","tags":["sqlite"]},"headers":[],"relativePath":"backend/sqlite/recursion.md","filePath":"backend/sqlite/recursion.md","lastUpdated":1705048859000}'),r={name:"backend/sqlite/recursion.md"},p={id:"frontmatter-title",tabindex:"-1"},h=t("a",{class:"header-anchor",href:"#frontmatter-title","aria-label":'Permalink to "{{ $frontmatter.title }}"'},"​",-1),o=n(`<p><code>SQLite</code> 的 <code>with</code> 从句提供了一种递归语法，可以有效地对树和图等结构进行查询</p><table><thead><tr><th>id</th><th>name</th><th>father</th><th>emperor_no</th></tr></thead><tbody><tr><td>1</td><td>曹操</td><td></td><td></td></tr><tr><td>2</td><td>曹植</td><td>1</td><td></td></tr><tr><td>3</td><td>曹丕</td><td>1</td><td>1</td></tr><tr><td>4</td><td>曹彰</td><td>1</td><td></td></tr><tr><td>5</td><td>曹冲</td><td>1</td><td></td></tr><tr><td>6</td><td>曹宇</td><td>1</td><td></td></tr><tr><td>7</td><td>曹楷</td><td>4</td><td></td></tr><tr><td>8</td><td>曹芳</td><td>7</td><td>3</td></tr><tr><td>9</td><td>曹睿</td><td>3</td><td>2</td></tr><tr><td>10</td><td>曹霖</td><td>3</td><td></td></tr><tr><td>11</td><td>曹髦</td><td>10</td><td>4</td></tr><tr><td>12</td><td>曹奂</td><td>6</td><td>5</td></tr></tbody></table><p>如果我们要求获取曹操所有的后代里，当过皇帝的人，并且按照代际顺序输出（子代-&gt;孙代-&gt;曾孙代）。这便是一个典型的广度优先搜索（Breadth First Search），该功能可用以下 <code>SQL</code> 语句进行查询：</p><div class="language-shell vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">with</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> recursive</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    cao</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> as </span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        select</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> * from family where name = </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;曹操&#39;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        union</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> all</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        select</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> family.* from cao join family on cao.id = family.father</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    )</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">select</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> * from cao where emperor_no is not null</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p><code>SQLite</code> 递归建表的核心是一条以 <code>union(all)</code> 连接的复合查询语句，其中 <code>union</code> 前面的语句构成递归搜索的起始数据，<code>union</code> 后的语句构成递归查询的生成语句（取出当前节点的所有子节点）。</p><p>如果写过基于队列来对树形结构进行广度优先搜索，那么会对 SQLite 这一语法很容易理解：</p><ol><li>在队列里产生初始数据</li><li>取出队列中的元素，输出该元素</li><li>将2步取出的元素，获取它的所有子节点，放入队列</li><li>继续进行第2步，直到队列为空</li></ol><hr><div class="language-shell vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">select</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> * from family where name = </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;曹操&#39;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>取出根节点，也就是曹操</p><div class="language-shell vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">select</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> family.* from cao join family on cao.id = family.father</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>取出当前遍历节点的所有子节点</p><div class="warning custom-block"><p class="custom-block-title">WARNING</p><p>虽然最终所有的输出结果都会到表cao里，但在生成语句里，cao指代的只是当前的遍历节点，它在生成语句里，只有一行数据</p></div><div class="language-shell vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">select</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> * from cao where emperor_no is not null</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>结果如下：</p><table><thead><tr><th>id</th><th>name</th><th>father</th><th>emperor_no</th></tr></thead><tbody><tr><td>3</td><td>曹丕</td><td>1</td><td>1</td></tr><tr><td>9</td><td>曹睿</td><td>3</td><td>2</td></tr><tr><td>12</td><td>曹奂</td><td>6</td><td>5</td></tr><tr><td>11</td><td>曹髦</td><td>10</td><td>4</td></tr><tr><td>8</td><td>曹芳</td><td>7</td><td>3</td></tr></tbody></table>`,16);function c(s,k,m,u,b,g){return l(),a("div",null,[t("h1",p,[i(d(s.$frontmatter.title)+" ",1),h]),o])}const v=e(r,[["render",c]]);export{E as __pageData,v as default};
