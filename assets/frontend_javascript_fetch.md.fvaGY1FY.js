import{_ as e,e as o,o as s,Z as c}from"./chunks/framework.tCCUWFfl.js";const u=JSON.parse('{"title":"fetch","description":"了解支持promise的HTTP请求方法","frontmatter":{"title":"fetch","description":"了解支持promise的HTTP请求方法","category":"javascript","tags":["fetch"]},"headers":[],"relativePath":"frontend/javascript/fetch.md","filePath":"frontend/javascript/fetch.md","lastUpdated":1686303485000}'),d={name:"frontend/javascript/fetch.md"},i=c(`<h1 id="fetch-api" tabindex="-1">Fetch API <a class="header-anchor" href="#fetch-api" aria-label="Permalink to &quot;Fetch API&quot;">​</a></h1><blockquote><p><code>fetch</code> 是基于 <code>promise</code> 的异步获取资源接口，支持 <code>promise</code> 的所有方法，<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API" target="_blank" rel="noreferrer">MDN</a></p></blockquote><h2 id="参数" tabindex="-1">参数 <a class="header-anchor" href="#参数" aria-label="Permalink to &quot;参数&quot;">​</a></h2><blockquote><p>第一个参数：获取资源的 <code>URL</code>。</p></blockquote><blockquote><p>第二个参数：<code>options</code> 对象，包括：</p></blockquote><ul><li><p><code>method</code>: 请求使用的方法，如 <code>GET、POST</code>。</p></li><li><p><code>headers</code>: 请求的头信息，形式为 <code>Headers</code> 的对象或包含 <code>ByteString</code> 值的对象字面量。</p></li><li><p><code>body</code>: 请求的 <code>body</code> 信息：可能是一个 <code>Blob</code>、 <code>BufferSource</code>、<code>FormData</code>、 <code>URLSearchParams</code> 或者 <code>USVString</code> 对象。<strong>注意 <code>GET</code> 或 <code>HEAD</code> 方法的请求不能包含 <code>body</code> 信息。</strong></p></li><li><p><code>mode</code>: 请求的模式，如 <code>cors</code>、 <code>no-cors</code> 或者 <code>same-origin</code>。</p></li><li><p><code>credentials</code>: 请求的 <code>credentials</code>，如 <code>omit</code>、 <code>same-origin</code> 或者 <code>include</code>。为了在当前域名内自动发送 <code>cookie</code> ， 必须提供这个选项， 从 <code>Chrome 50</code> 开始， 这个属性也可以接受 <code>FederatedCredential</code> 实例或是一个 <code>PasswordCredential</code> 实例。</p></li><li><p><code>cache</code>: 请求的 <code>cache</code> 模式: <code>default</code>、 <code>no-store</code> 、 <code>reload</code> 、 <code>no-cache</code> 、 <code>force-cache</code> 或者 <code>only-if-cached</code>。</p></li><li><p><code>redirect</code>: 可用的 <code>redirect</code> 模式: <code>follow</code> (自动重定向)， <code>error</code> (如果产生重定向将自动终止并且抛出一个错误)， 或者 <code>manual</code> (手动处理重定向). 在 <code>Chrome</code> 中，<code>Chrome 47</code> 之前的默认值是 <code>follow</code>，从 <code>Chrome</code> 47开始是 <code>manual</code>。</p></li><li><p><code>referrer</code>: 一个 <code>USVString</code> ，可以是 <code>no-referrer</code> 、 <code>client</code> 或一个 <code>URL</code>。默认是 <code>client</code>。</p></li><li><p><code>referrerPolicy</code>: 指定引用 <code>HTTP</code> 标头的值。可能是以下之一 <code>no-referrer</code>、 <code>no-referrer-when-downgrade</code>、 <code>origin</code>、 <code>origin-when-cross-origin</code>、 <code>unsafe-url</code>.</p></li><li><p><code>integrity</code>: 包括请求的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/Security/Subresource_Integrity" target="_blank" rel="noreferrer">subresource integrity</a> 值（例如： <code>sha256-BpfBw7ivV8q2jLiT13fxDYAe2tJllusRSZ273h2nFSE=</code>）。</p></li></ul><blockquote><blockquote><p>上面诸多 <strong>option</strong> 中，其实常用的就是 <strong>method、headers、body</strong> 以及 <strong>mode</strong> 等</p></blockquote></blockquote><h3 id="headers" tabindex="-1">headers <a class="header-anchor" href="#headers" aria-label="Permalink to &quot;headers&quot;">​</a></h3><p>可以为 <code>Headers</code> 对象，也可以是一个对象字面量，通常情况下对象字面量就足够</p><div class="language-ts vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> url</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;https://......&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> headers</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  Accept: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;image/jpeg&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  &#39;Content-Type&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;application/x-www-form-urlencoded; charset=UTF-8&#39;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">fetch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(url, { headers }).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">then</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> () {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // ...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><h3 id="mode" tabindex="-1">mode <a class="header-anchor" href="#mode" aria-label="Permalink to &quot;mode&quot;">​</a></h3><ul><li><p><code>same-origin</code> 表示必须同源，绝对禁止跨域，这个是老版本浏览器默认的安全策略。</p></li><li><p><code>cors</code> 表示允许跨域，顾名思义它是以 <code>CORS</code> 的形式跨域；当然该模式也可以同域请求。只需要服务器的响应头中带有 <code>Access-Control-Allow-Origin: *</code> 就行。</p></li><li><p><code>no-cors</code> 这个就很特殊了，字面意思是禁止以 <code>CORS</code> 的形式跨域，其实它的效果是，对外域的请求可以发送，外域服务器无论设不设 <code>Access-Control-Allow-Origin: *</code> 都会接收请求并处理请求，但是浏览器不接收响应，即使外域返回了内容，浏览器也当做没接到。 这个 <code>no-cors</code> 的用途是保证数据安全。</p></li></ul><h2 id="response" tabindex="-1">Response <a class="header-anchor" href="#response" aria-label="Permalink to &quot;Response&quot;">​</a></h2><p>传给 <code>then</code> 的回调函数可以接收一个参数，这个参数就是 <code>Response</code>，它的属性基本上是只读属性。</p><ul><li><p><code>Response.clone()</code> 创建一个 <code>Response</code> 对象的克隆</p></li><li><p><code>Response.error()</code> 返回一个绑定了网络错误的新的 <code>Response</code> 对象</p></li><li><p><code>Response.redirect()</code> 用另一个URL创建一个新的 <code>Response</code>.</p></li><li><p><code>Response.arrayBuffer()</code> 读取 <code>Response</code> 对象并且将它设置为已读（因为 <code>Responses</code> 对象被设置为了 <code>stream</code> 的方式，所以它们只能被读取一次） ，并返回一个被解析为 <code>ArrayBuffer</code> 格式的 <code>promise</code> 对象</p></li><li><p><code>Response.blob()</code> 读取 <code>Response</code> 对象并且将它设置为已读（因为 <code>Responses</code> 对象被设置为了 <code>stream</code> 的方式，所以它们只能被读取一次） ，并返回一个被解析为 <code>Blob</code> 格式的 <code>promise</code> 对象</p></li><li><p><code>Response.formData()</code> 读取 <code>Response</code> 对象并且将它设置为已读（因为 <code>Responses</code> 对象被设置为了 <code>stream</code> 的方式，所以它们只能被读取一次） ，并返回一个被解析为 <code>FormData</code> 格式的 <code>promise</code> 对象</p></li><li><p><code>Response.json()</code> 读取 <code>Response</code> 对象并且将它设置为已读（因为 <code>Responses</code> 对象被设置为了 <code>stream</code> 的方式，所以它们只能被读取一次） ，并返回一个被解析为 <code>JSON</code> 格式的 <code>promise</code> 对象</p></li><li><p><code>Response.text()</code> 读取 <code>Response</code> 对象并且将它设置为已读（因为 <code>Responses</code> 对象被设置为了 <code>stream</code> 的方式，所以它们只能被读取一次） ，并返回一个被解析为 <code>USVString</code> 格式的 <code>promise</code> 对象</p></li></ul>`,15),a=[i];function n(r,l,t,p,h,k){return s(),o("div",null,a)}const g=e(d,[["render",n]]);export{u as __pageData,g as default};
